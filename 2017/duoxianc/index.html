<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="pengSite">
  
  
  
  <link rel="prev" href="/2017/stream/" />
  <link rel="next" href="/2017/wlbc/" />
  <link rel="canonical" href="/2017/duoxianc/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           java多线程知识总结 | PengSite
       
  </title>
  <meta name="title" content="java多线程知识总结 | PengSite">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "\/"
    },
    "articleSection" : "posts",
    "name" : "java多线程知识总结",
    "headline" : "java多线程知识总结",
    "description" : "多线程   概念：是指从软件或者硬件上实现多个线程并发执行的技术\n  具有多线程能力的计算机因有硬件支持而能够在同一时间执行多个线程，提升性能。\n  并行：在同一时刻，有多个指令在多个CPU上同时执行\n  并发：在同一时刻，有多个指令在单个CPU上交替执行\n  进程：是正在运行的软件\n 独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位 动态性：进程的实质是程序的一次执行过程，进程是动态产生，动态消亡 并发性：任何进程都可以同其它进程一起并发执行    线程：是进程中的单个顺序控制流，是一条执行路径\n 单线程：一个进程如果只有一条执行路径，则称为单线程程序 多线程：一个进程如果有多条执行路径，则称为多线程程序    多线程的实现方案\n  继承Thread类的方式进行实现\n  定义一个类MyThread继承Thread类\n  在MyThread类中重写run()方法\n  创建MyThread类的对象\n  启动线程\n  代码实现\npublic class MyThread extends Thread{ @Override public void run() { for (int i = 0; i \u0026lt; 100; i\u002b\u002b) { System.out.println(\u0026quot;线程开启了\u0026quot;\u002bi); } } } 测试类：",
    "inLanguage" : "zh-CN",
    "author" : "PengSite",
    "creator" : "PengSite",
    "publisher": "PengSite",
    "accountablePerson" : "PengSite",
    "copyrightHolder" : "PengSite",
    "copyrightYear" : "2017",
    "datePublished": "2017-10-09 00:00:00 \u002b0000 UTC",
    "dateModified" : "2017-10-09 00:00:00 \u002b0000 UTC",
    "url" : "\/2017\/duoxianc\/",
    "wordCount" : "1843",
    "keywords" : [ "java","多线程", "PengSite"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="/">PengSite</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">博客</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">关于</a>
                
                <a class="menu-item" href="/about/" title="About Hugo">About Hugo</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="/">PengSite</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">博客</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">关于</a>
                
                <a class="menu-item" href="/about/" title="About Hugo">About Hugo</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">java多线程知识总结</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="/" rel="author">PengSite</a> with ♥ 
                <span class="post-time">
                on <time datetime=2017-10-09 itemprop="datePublished">October 9, 2017</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="/categories/uncategorized/"> Uncategorized </a>
                        
                </span>
        </div>
    </header>
    <div class="post-content">
        

        

        
        
     
          
          
          

          
          
          

          <h3 id="多线程">多线程</h3>
<ul>
<li>
<p>概念：是指从软件或者硬件上实现多个线程并发执行的技术</p>
</li>
<li>
<p>具有多线程能力的计算机因有硬件支持而能够在同一时间执行多个线程，提升性能。</p>
</li>
<li>
<p>并行：在同一时刻，有多个指令在多个CPU上同时执行</p>
</li>
<li>
<p>并发：在同一时刻，有多个指令在单个CPU上交替执行</p>
</li>
<li>
<p>进程：是正在运行的软件</p>
<ul>
<li>独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位</li>
<li>动态性：进程的实质是程序的一次执行过程，进程是动态产生，动态消亡</li>
<li>并发性：任何进程都可以同其它进程一起并发执行</li>
</ul>
</li>
<li>
<p>线程：是进程中的单个顺序控制流，是一条执行路径</p>
<ul>
<li>单线程：一个进程如果只有一条执行路径，则称为单线程程序</li>
<li>多线程：一个进程如果有多条执行路径，则称为多线程程序</li>
</ul>
</li>
<li>
<p>多线程的实现方案</p>
<ul>
<li>
<p>继承<code>Thread</code>类的方式进行实现</p>
<ul>
<li>
<p>定义一个类MyThread继承<code>Thread</code>类</p>
</li>
<li>
<p>在MyThread类中重写<code>run()</code>方法</p>
</li>
<li>
<p>创建MyThread类的对象</p>
</li>
<li>
<p>启动线程</p>
</li>
<li>
<p>代码实现</p>
<pre><code>public class MyThread extends Thread{
    @Override
    public void run() {
        for (int i = 0; i &lt; 100; i++) {
            System.out.println(&quot;线程开启了&quot;+i);
        }
    }
}
</code></pre><p>测试类：</p>
<pre><code>    public static void main(String[] args) {
        //创建线程对象
        MyThread myThread1 = new MyThread();
        //创建线程对象
        MyThread myThread2 = new MyThread();
        //第一次启动线程
        myThread1.start();
        //第一次启动线程
        myThread2.start();
      
    }
</code></pre></li>
<li>
<p>思考：为什么要重写<code>run()</code>方法？</p>
</li>
<li>
<p>答：因为<code>run()</code>是用来封装被线程执行的代码的</p>
</li>
<li>
<p>思考：<code>run()</code>方法和<code>start()</code>方法的区别？</p>
</li>
<li>
<p>答：<code>run()</code>：封装线程执行的代码，直接调用，相当于普通方法的调用，并没有开启线程</p>
</li>
<li>
<p><code>start</code>：启动线程，然后由JVM调用此线程的<code>run()</code>方法</p>
</li>
</ul>
</li>
<li>
<p>实现Runnable</p>
<ul>
<li>
<p>定义一个类MyRunnable实现<code>Runnable</code>接口</p>
</li>
<li>
<p>在MyRunnable类中重写<code>run()</code>方法</p>
</li>
<li>
<p>创建MyRunnable类的对象</p>
</li>
<li>
<p>创建Thread类的对象，把MyRunable对象作为构造的参数对象</p>
</li>
<li>
<p>启动线程</p>
</li>
<li>
<p>代码实现</p>
<pre><code>public class MyRunnable implements Runnable{
      
    @Override
    public void run() {
        for (int i = 0; i &lt; 100; i++) {
            System.out.println(&quot;第二种方式实现多线程&quot;+i);
        }
    }
}
</code></pre></li>
<li>
<p>测试类</p>
<pre><code>    public static void main(String[] args) {
        //创建一个参数对象
        MyRunnable mr = new MyRunnable();
        //创建一个线程对象，并把参数传递给这个线程
        //在线程启动之后，执行的就是参数里面的run方法
        Thread t1 = new Thread(mr);
        //开启线程
        t1.start();
        MyRunnable mr2 = new MyRunnable();
        Thread th2 = new Thread(mr2);
        th2.start();
    }
</code></pre></li>
</ul>
</li>
<li>
<p>利用Callable和Future接口方式实现</p>
<ul>
<li>
<p>定义一个MyCallable类实现<code>Callable</code>接口</p>
</li>
<li>
<p>在MyCallable类中重写<code>call()</code>方法</p>
</li>
<li>
<p>创建MyCallable类的对象</p>
</li>
<li>
<p>创建Future的实现类FutureTask对象，把MyCallable对象作为构造方法的参数</p>
</li>
<li>
<p>创建Thread类的对象，把FutureTask对象作为构造方法的参数</p>
</li>
<li>
<p>代码实现</p>
<pre><code>public class MyCallable implements Callable&lt;String&gt; {
    @Override
    public String call() throws IOException {
        for (int i = 0; i &lt; 99; i++) {
            System.out.println(&quot;我是第三种方法&quot;+i);
        }
        return &quot;好的&quot;;
    }
}
</code></pre></li>
<li>
<p>测试类</p>
<pre><code>    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //线程开启后需要执行里面的Call方法
        MyCallable mc = new MyCallable();
        //可以获取线程执行完毕之后的结果，也可以作为参数传递给Thread对象
        FutureTask&lt;String&gt; ft = new FutureTask&lt;&gt;(mc);
        //创建线程对象
        Thread t1 = new Thread(ft);
        //开启线程
        t1.start();
        String s = ft.get();
        System.out.println(s);
      
    }
</code></pre></li>
</ul>
</li>
<li>
<p>三种实现方式的对比</p>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>实现Runnable、Callable接口</td>
<td>扩展性强，实现该接口的同时还可以继承其他的类</td>
<td>编程相对复杂，不能直接使用Thread类中的方法</td>
</tr>
<tr>
<td>继承Thread类</td>
<td>编程比较简单，可以直接使用Thread类中的方法</td>
<td>扩展性较差，不能再继承其他的类</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>Thread类中常见方法</p>
<ul>
<li>
<p><code>String getName()</code> :返回此线程的名称</p>
<ul>
<li>线程是有默认名字的，格式是<code>	Thread-编号</code></li>
</ul>
</li>
<li>
<p>Thread类中设置线程的名字</p>
<ul>
<li><code>void setName(String name)</code>:将此线程的名称更改为等于参数name</li>
<li>通过构造方法也可以设置线程名称
<ul>
<li><code>Thread(String name)</code>:给线程传递一个名字</li>
</ul>
</li>
</ul>
</li>
<li>
<p>获得当前线程的对象</p>
<ul>
<li>
<p><code>public static Thread currentThread()</code>:返回对当前正在执行的线程对象的引用</p>
<pre><code>    public static void main(String[] args) {
        String name = Thread.currentThread().getName();
        System.out.println(name);
    }
</code></pre></li>
</ul>
</li>
<li>
<p>线程休眠</p>
<ul>
<li>
<p><code>public static void sleep(long time)</code>:让线程休眠指定的时间，单位为毫秒</p>
<pre><code>    public static void main(String[] args) throws InterruptedException {
        System.out.println(&quot;睡觉前&quot;);
        Thread.sleep(3000);
        System.out.println(&quot;睡醒了&quot;);
    }
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li>
<p>线程调度</p>
<ul>
<li>多线程的并发运行
<ul>
<li>计算机中的CPU，在任意时刻只能执行一条机器指令，每个线程只有获得CPU的使用权才能执行代码，各个线程轮流获得CPU的使用权，分别执行各自的任务。</li>
</ul>
</li>
<li>线程的两种调度模型
<ul>
<li>分时调度模型：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片</li>
<li>抢占式调度模型：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的CPU时间片相对多一些</li>
<li>java使用的抢占式调度模型</li>
</ul>
</li>
</ul>
</li>
<li>
<p>线程的优先级</p>
<ul>
<li>
<p><code>public final void setPriority(int newPriority)</code>:设置线程的优先级</p>
</li>
<li>
<p><code>public final int getPriority() </code>:获取线程的优先级</p>
</li>
<li>
<p>代码实现</p>
<pre><code>    public static void main(String[] args) {
        //线程开启后需要执行里面的Call方法
        MyCallable mc = new MyCallable();
        //可以获取线程执行完毕之后的结果，也可以作为参数传递给Thread对象
        FutureTask&lt;String&gt; ft = new FutureTask&lt;&gt;(mc);
    
        Thread t1 = new Thread(ft);
        //给线程一个名字
        t1.setName(&quot;飞机&quot;);
        //设置线程的优先级
        t1.setPriority(7);
        //获取优先级
        int priority = t1.getPriority();
        //打印优先级
        System.out.println(priority);
        //开启线程
        t1.start();
    
        MyCallable mc1 = new MyCallable();
    
        FutureTask&lt;String&gt; ft1 = new FutureTask&lt;&gt;(mc1);
    
        Thread t2 = new Thread(ft1);
    
        t2.setName(&quot;坦克&quot;);
        t2.setPriority(3);
        int priority1 = t2.getPriority();
        System.out.println(priority1);
        t2.start();
    }
</code></pre></li>
</ul>
</li>
<li>
<p>后台线程/守护线程</p>
<ul>
<li>
<p><code>public final void setDaemon(boolean on)</code>:设置为守护线程</p>
</li>
<li>
<p>代码实现</p>
<pre><code>//第一个
public class MyThread extends Thread{
    @Override
    public void run() {
        for (int i = 0; i &lt; 5; i++) {
            System.out.println(Thread.currentThread().getName()+&quot;---&quot;+i);
        }
    }
}
//第二个
public class MyThread1 extends Thread{
    @Override
    public void run() {
        for (int i = 0; i &lt; 100; i++) {
    
            System.out.println(Thread.currentThread().getName()+&quot;---&quot;+i);
        }
    }
}
</code></pre></li>
<li>
<p>测试类</p>
<pre><code>    public static void main(String[] args) {
        MyThread mt = new MyThread();
        MyThread1 mt1 = new MyThread1();
    
        mt.setName(&quot;女神&quot;);
        mt1.setName(&quot;备胎&quot;);
        mt1.setDaemon(true);
        mt.start();
        mt1.start();
    }
}
</code></pre></li>
</ul>
</li>
<li>
<p>如何解决线程安全问题</p>
<ul>
<li>让程序没有安全问题的环境</li>
<li>实现
<ul>
<li>把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可</li>
<li>java提供了同步代码块的方式来解决</li>
</ul>
</li>
</ul>
</li>
<li>
<p>同步代码块</p>
<ul>
<li>格式
<ul>
<li><code>synchronized(任意对象){多条语句操作共享数据的代码}</code></li>
</ul>
</li>
<li>默认情况是打开的，只要有一个线程进去执行代码了，锁就会关闭</li>
<li>当线程执行完毕，锁就会自动打开</li>
<li>同步的好处和弊端
<ul>
<li>好处：解决了多线程的数据安全问题</li>
<li>弊端：当线程很多时，每个线程都会去判断同步上的锁，这是很消耗资源的，会降低程序的运行效率</li>
</ul>
</li>
<li><code>Synchronized</code>：锁对象一定是要唯一</li>
</ul>
</li>
<li>
<p>线程安全案例&mdash;卖票问题</p>
<ul>
<li>
<p>代码实现</p>
<pre><code>public class Ticket extends Thread {
    private static int ticketCount = 100;
    
    public int getTicketCount() {
        return ticketCount;
    }
    
    private static Object object = new Object();
    
    @Override
    public void run() {
        while (true) {
            synchronized (object) {
                if (getTicketCount() &lt;= 0) {
                    System.out.println(&quot;卖完了&quot;);
                    break;
    
                } else {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    ticketCount--;
    
                    System.out.println(Thread.currentThread().getName() + &quot;正在卖第&quot; + ticketCount + &quot;张票&quot;);
    
                }
            }
        }
    }
}
</code></pre></li>
<li>
<p>测试类</p>
<pre><code>    public static void main(String[] args) {
        Ticket tk1 = new Ticket();
        Ticket tk2 = new Ticket();
    
        tk1.setName(&quot;窗口1&quot;);
        tk2.setName(&quot;窗口2&quot;);
    
        tk1.start();
        tk2.start();
    
    
    }
</code></pre></li>
</ul>
</li>
<li>
<p>同步方法</p>
<ul>
<li>把<code>synchronized</code>关键字加到方法上</li>
<li>格式
<ul>
<li>修饰符 <code>synchronized</code> 返回值类型 方法名(方法参数){ }</li>
</ul>
</li>
</ul>
</li>
<li>
<p>同步代码块和同步方法的区别：</p>
<ul>
<li>
<p>同步代码块可以锁住指定代码，同步方法是锁住方法中所有代码</p>
</li>
<li>
<p>同步代码块可以指定锁对象，同步方法不能指定锁对象</p>
</li>
<li>
<p>同步方法的锁对象是：<code>this</code></p>
</li>
<li>
<p>代码实现</p>
<pre><code>public class MyRunnable implements Runnable {
    private int ticketCount = 100;
    @Override
    public void run() {
        while (true){
            if(&quot;窗口1&quot;.equals(Thread.currentThread().getName())){
                //执行线程1
                boolean result = synchronizedMethed();
                if (result){
                    break;
                }
            }
            if(&quot;窗口2&quot;.equals(Thread.currentThread().getName())){
                //执行线程2
                synchronized (this){
                    if (ticketCount == 0){
                        break;
                    }else {
                        try {
                            Thread.sleep(100);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        ticketCount--;
                        System.out.println(Thread.currentThread().getName()+&quot;还剩&quot;+ticketCount+&quot;张票！&quot;);
                    }
                }
    
            }
        }
    }
    
    private synchronized boolean synchronizedMethed() {
           if (ticketCount == 0){
                return true;
           }else {
               try {
                   Thread.sleep(100);
               } catch (InterruptedException e) {
                   e.printStackTrace();
               }
               ticketCount--;
               System.out.println(Thread.currentThread().getName()+&quot;还剩&quot;+ticketCount+&quot;张票！&quot;);
               return false;
           }
    
    }
}
</code></pre></li>
<li>
<p>测试类</p>
<pre><code>    public static void main(String[] args) {
        MyRunnable mr = new MyRunnable();
    
        Thread t1 = new Thread(mr);
        Thread t2 = new Thread(mr);
    
        t1.setName(&quot;窗口1&quot;);
        t2.setName(&quot;窗口2&quot;);
    
        t1.start();
        t2.start();
    }
</code></pre></li>
</ul>
</li>
<li>
<p>同步静态方法</p>
<ul>
<li>格式：修饰符<code>static synchronized</code>返回值类型方法名(方法参数){ }</li>
<li>同步静态方法的锁对象是：<code>类名.class</code></li>
</ul>
</li>
<li>
<p>Lock锁</p>
<ul>
<li>
<p>Lock是接口，不能直接实例化，这里采用它的实现类<code>ReentrantLock</code>来实例化</p>
</li>
<li>
<p><code>ReentrantLock</code>的构造方法</p>
<ul>
<li><code>ReentrantLock()</code>:创建一个<code>ReentrantLock</code>的实例</li>
</ul>
</li>
<li>
<p>代码实现</p>
<pre><code>public class Ticket extends Thread {
    private static int ticketCount = 100;
    
    public int getTicketCount() {
        return ticketCount;
    }
    
    //    private static Object object = new Object();
    ReentrantLock rtl = new ReentrantLock();
    
    @Override
    public void run() {
    
        while (true) {
            try {
                //            synchronized (object) {
                rtl.lock();
                if (getTicketCount() &lt;= 0) {
                    System.out.println(&quot;卖完了&quot;);
                    break;
    
                } else {
                    Thread.sleep(100);
                    ticketCount--;
                    System.out.println(Thread.currentThread().getName() + &quot;正在卖第&quot; + ticketCount + &quot;张票&quot;);
                }
    
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                rtl.unlock();
            }
        }
    }
}
</code></pre></li>
<li>
<p>测试类</p>
<pre><code>    public static void main(String[] args) {
        Ticket tk1 = new Ticket();
        Ticket tk2 = new Ticket();
    
        tk1.setName(&quot;窗口1&quot;);
        tk2.setName(&quot;窗口2&quot;);
    
        tk1.start();
        tk2.start();
    }
</code></pre></li>
</ul>
</li>
<li>
<p>死锁</p>
<ul>
<li>线程死锁是指由于两个或者多个线程相互持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行</li>
</ul>
</li>
<li>
<p>生产者和消费者模型</p>
<ul>
<li>
<p>概述</p>
<ul>
<li>生产者消费者模式是一个十分经典的多线程协作的模式，弄懂生产者消费者问题能够让我们对多线程编程的思想理解的更加深刻</li>
</ul>
</li>
<li>
<p>等待和唤醒的方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>void wait()</td>
<td>导致当前线程等待，直到另一个线程调用该对象的notify()方法或notifyAll()方法</td>
</tr>
<tr>
<td>void notify()</td>
<td>唤醒正在等待对象监视器的单个线程</td>
</tr>
<tr>
<td>void notifyAll()</td>
<td>唤醒正在等待对象监视器的所有线程</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>代码实现</p>
</li>
<li>
<p><code>Foodie</code>类</p>
<pre><code>public class Foodie extends Thread{
    private Desk desk;
    
    public Foodie(Desk desk) {
        this.desk = desk;
    }
    
    /*消费者步骤
     * 1、判断桌子上是否有汉堡包
     * 2、如果没有就等待
     * 3、如果有就开吃
     * 4、吃完之后，桌子上的汉堡就没有了叫醒等待的生产者继续生产
     * 汉堡包总数减一
     * */
    /*
    1、while(true)死循环
    2、synchronized锁，锁对象要唯一
    3、判断，共享数据是否结束，结束
    4、判断，共享数据是否结束，没结束
    * */
    @Override
    public void run() {
        while (true){
            synchronized (desk.getLock()){
                if (desk.getCount() == 0){
                    break;
                }else {
                    if (desk.isFlag()){
                        //有
                        System.out.println(&quot;消费者在吃汉堡包&quot;);
                        desk.setFlag(false);
                        desk.getLock().notifyAll();
                        desk.setCount(desk.getCount()-1);
                    }else{
                        //没有就等待
                        //使用什么对象当做锁，那么就必须用这个对象去调用等待和唤醒的方法
                        try {
                            desk.getLock().wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
    
                    }
                }
            }
        }
    }
}
</code></pre></li>
<li>
<p><code>Cooker</code>类</p>
<pre><code>public class Cooker extends Thread{
    private Desk desk;
    
    public Cooker(Desk desk) {
        this.desk = desk;
    }
    /*生产者步骤
     * 1、判断桌子上是否有汉堡包，如果有就等待，如果没有就生产
     * 2、把汉堡放在桌子上
     * 叫醒等待的消费者开吃
     * */
    
    @Override
    public void run() {
        while (true){
            synchronized (desk.getLock()){
                if(desk.getCount() == 0){
                    break;
                }else {
                    if (!desk.isFlag()){
                        //生产
                        System.out.println(&quot;正在生产汉堡包&quot;);
                        desk.setFlag(true);
                        desk.getLock().notifyAll();
                    }else {
                        //有就等待
                        try {
                            desk.getLock().wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }
    }
}
</code></pre></li>
<li>
<p><code>Desk</code>类</p>
<pre><code>public class Desk {
    //定义一个标记
    //true 表示桌子上有汉堡包，此时允许消费者执行
    //false 表示桌子上没有汉堡包，此时允许生产者执行
//    public static boolean flag = true;
    private boolean flag;
    
    //汉堡包的总数量
//    public static int count = 10;
    private int count;
    //锁对象
//    public static final Object lock = new Object();
    private final Object lock = new Object();
    
    public Desk() {
        this(false,10);
    }
    
    public Desk(boolean flag, int count) {
        this.flag = flag;
        this.count = count;
    }
    
    public boolean isFlag() {
        return flag;
    }
    
    public void setFlag(boolean flag) {
        this.flag = flag;
    }
    
    public int getCount() {
        return count;
    }
    
    public void setCount(int count) {
        this.count = count;
    }
    
    public Object getLock() {
        return lock;
    }
    
}
</code></pre></li>
<li>
<p>测试类</p>
<pre><code>public class Demo {
    public static void main(String[] args) {
        /*消费者步骤
        * 1、判断桌子上是否有汉堡包
        * 2、如果没有就等待
        * 3、如果有就开吃
        * 4、吃完之后，桌子上的汉堡就没有了叫醒等待的生产者继续生产
        * 汉堡包总数减一
        * */
    
        /*生产者步骤
        * 1、判断桌子上是否有汉堡包，如果有就等待，如果没有就生产
        * 2、把汉堡放在桌子上
        * 叫醒等待的消费者开吃
        * */
        Desk desk = new Desk();
    
        Foodie f = new Foodie(desk);
        Cooker c = new Cooker(desk);
    
        f.start();
        c.start();
    }
}
</code></pre></li>
<li>
<p>阻塞队列实现等待唤醒机制</p>
<ul>
<li>
<p><code>BlockingQueue</code>的核心方法</p>
<ul>
<li>
<p><code>put(anObject)</code>:将参数放入队列，如果放不进去会阻塞</p>
</li>
<li>
<p><code>take()</code>:取出第一个数据，取不到会阻塞</p>
<pre><code>    public static void main(String[] args) throws InterruptedException {
        //阻塞队列的基本用法
        //创建阻塞队列的对象，容量为1
        ArrayBlockingQueue&lt;String&gt; arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(1);
        
        //储存元素
        arrayBlockingQueue.put(&quot;汉堡包&quot;);
        
        //取元素
        System.out.println(arrayBlockingQueue.take());
        System.out.println(arrayBlockingQueue.take());
        
        System.out.println(&quot;程序结束了&quot;);
    }
</code></pre></li>
</ul>
</li>
<li>
<p>常见<code>BlockingQueue</code>:</p>
<ul>
<li><code>ArrayBlockingQueue</code>:底层是数组，有界</li>
<li><code>LinkedBlockingQueue</code>:底层是链表，无界，但不是真正的无界，最大为int的最大值</li>
</ul>
</li>
</ul>
</li>
<li>
<p>等待队列和唤醒机制配合</p>
<ul>
<li>
<p>代码实现</p>
</li>
<li>
<p>Cooker类</p>
<pre><code>public class Cooker extends Thread{
    private ArrayBlockingQueue&lt;String&gt; arrayBlockingQueue;
    public Cooker(ArrayBlockingQueue&lt;String&gt; arrayBlockingQueue) {
        this.arrayBlockingQueue = arrayBlockingQueue;
    }
      
    @Override
    public void run() {
        while (true) {
            try {
                arrayBlockingQueue.put(&quot;汉堡包&quot;);
                System.out.println(&quot;厨师放了一个汉堡包&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
      
    }
}
</code></pre></li>
<li>
<p>Foodie类</p>
<pre><code>public class Foodie extends Thread{
    private ArrayBlockingQueue&lt;String&gt; arrayBlockingQueue;
    public Foodie(ArrayBlockingQueue&lt;String&gt; arrayBlockingQueue) {
        this.arrayBlockingQueue =arrayBlockingQueue;
    }
      
    @Override
    public void run() {
        while (true) {
            try {
                String take = arrayBlockingQueue.take();
                System.out.println(&quot;吃货从队列获取一个&quot;+take);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre></li>
<li>
<p>测试类</p>
<pre><code>public class Demo {
    public static void main(String[] args) {
        //创建一个阻塞队列，容量为1
        ArrayBlockingQueue&lt;String&gt; arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(1);
      
        //创建线程并开启
        Cooker c = new Cooker(arrayBlockingQueue);
        Foodie f = new Foodie(arrayBlockingQueue);
      
        c.start();
        f.start();
    }
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li>
<p>线程的状态</p>
<ul>
<li>虚拟中线程的六种状态
<ul>
<li>新建状态(NEW)   &mdash;创建线程对象</li>
<li>就绪状态(RUNNABLE)  &mdash; start方法</li>
<li>阻塞状态(BLOCKED)   &mdash; 无法获得锁对象</li>
<li>等待状态(WAITING)  &mdash; wait方法</li>
<li>计时等待(TIMED_WAITING)  &mdash; sleep方法</li>
<li>结束状态(TERMINATED)  &mdash; 全部代码运行完毕</li>
</ul>
</li>
</ul>
</li>
<li>
<p>线程池</p>
<ul>
<li>
<p>创建Executors中的静态方法</p>
</li>
<li>
<p>submit方法</p>
<ul>
<li>池子会自动的帮我们创建对象，任务执行完毕，也会自动把线程对象归还池子</li>
</ul>
</li>
<li>
<p>shutdown方法</p>
</li>
<li>
<p><code>static ExecutorService newCachedThreadpool()</code>:创建一个默认的线程池</p>
<pre><code>public static void main(String[] args) throws InterruptedException {
        //1、创建一个默认的线程池对象，池子中默认是空的，默认最多可以容纳int类型的最大值
        //2、Executors  ---  可以帮助我们创建线程池对象
        //3、ExecutorService帮助我们控制线程池
            ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();
            newCachedThreadPool.submit(()-&gt;{
                System.out.println(Thread.currentThread().getName()+&quot;在执行了&quot;);
            });
            Thread.sleep(2000);
    			
            newCachedThreadPool.submit(()-&gt;{
                System.out.println(Thread.currentThread().getName()+&quot;在执行了&quot;);
            });
    			
            newCachedThreadPool.shutdown();
	}
</code></pre></li>
<li>
<p><code>static newFixedThreadPool(int nThreads)</code>:创建一个指定最多线程数量的线程池</p>
<pre><code>	public static void main(String[] args) {
        //参数不是初始值而是最大值
        ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(10);
    		
        newFixedThreadPool .submit(()-&gt;{
            System.out.println(Thread.currentThread().getName()+&quot;在执行了&quot;);
        });
        newFixedThreadPool .submit(()-&gt;{
            System.out.println(Thread.currentThread().getName()+&quot;在执行了&quot;);
        });
    		
        newFixedThreadPool.shutdown();
	}
</code></pre></li>
<li>
<p>自定义线程池对象</p>
</li>
<li>
<p><code>ThreadPoolExecytor threadpoolexecutor = new ThreadPoolExecutor</code></p>
<p>(核心线程数量，最大线程数量，空闲线程最大存活时间，任务队列，创建线程工厂，任务的拒绝策略)</p>
<pre><code>	//自己创建线程池对象
	//参数一：核心线程数量   ---   不能小于0
	//参数二：最大线程数   ---   不能小于等于0，最大数量&gt;=核心线程数量
	//参数三：空闲线程最大存活时间   ---   不能小于0
	//参数四：时间单位   ---   时间单位
	//参数五：任务队列   ---   不能为null
	//参数六：创建线程工厂   ---   不能为null
	//参数七：任务的拒绝策略   ---   不能为null
	public static void main(String[] args) {
        ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(2,5, 2, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(10),Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());
        poolExecutor.submit(()-&gt;{
            System.out.println(Thread.currentThread().getName()+&quot;在执行了&quot;);
        });
    		
        poolExecutor.submit(()-&gt;{
            System.out.println(Thread.currentThread().getName()+&quot;在执行了&quot;);
        });
    		
        poolExecutor.shutdown();
	}
</code></pre></li>
<li>
<p>任务拒绝策略</p>
<ul>
<li><code>ThreadPoolExecutor.AbortPolicy</code>:丢弃任务并抛出<code>RejectedExecutionException</code>异常，是默认策略</li>
<li><code>ThreadPoolExecutor.DiscardPolicy</code>:丢弃任务，但是不抛出异常，不推荐</li>
<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>:抛弃队列中等待最久的任务，然后把当前任务加入队列中</li>
<li><code>ThreadPoolExecutor.CallerRunsPolicy</code>:调用任务的run()方法绕过线程池直接执行</li>
</ul>
</li>
<li>
<p>volatile</p>
<ul>
<li>
<p>线程内存</p>
<ul>
<li>堆内存是唯一的，每一个线程都有自己的线程</li>
<li>每一个线程在使用堆里面变量的时候，都会先拷贝一份到变量的副本中</li>
<li>在线程中，每一次使用是从变量的副本中获取的</li>
</ul>
</li>
<li>
<p>Volatile关键字</p>
<ul>
<li>
<p>强制线程每次在使用的时候，都会看一下共享区域最新的值</p>
</li>
<li>
<p>代码实现</p>
</li>
<li>
<p>MyThread1</p>
<pre><code>public class MyThread1 extends Thread {
	@Override
	public void run() {
        while (Money.money == 100000) {
        
        }
        System.out.println(&quot;结婚基金已经不是十万元&quot;);
	}
}
</code></pre></li>
<li>
<p>MyThread2</p>
<pre><code>public class MyThread2 extends Thread{
	@Override
	public void run() {
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        Money.money = 90000;
	}
}
</code></pre></li>
<li>
<p>Money</p>
<pre><code>public class Money {
     public static volatile int money = 100000;
}
</code></pre></li>
<li>
<p>Demo</p>
<pre><code>public class Volatile {
	public static void main(String[] args) {
        MyThread1 mt1 = new MyThread1();
        mt1.setName(&quot;小路同学&quot;);
        mt1.start();
        		
        MyThread2 mt2 = new MyThread2();
        mt2.setName(&quot;小明同学&quot;);
        mt2.start();
	}
}
</code></pre></li>
<li>
<p>同步代码块实现</p>
</li>
<li>
<p>MyThread1</p>
<pre><code>public class MyThread1 extends Thread {
	@Override
	public void run() {
        while(true) {
            synchronized (Money.lock) {
                if (Money.money!=100000) {
                    System.out.println(&quot;结婚基金已经不是十万元&quot;);
                    break;
                }
            }
        }	
	}
}
</code></pre></li>
<li>
<p>MyThread2</p>
<pre><code>public class MyThread2 extends Thread{
	@Override
	public void run() {
        synchronized (Money.lock) {
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
            Money.money = 90000;
        }
	}
}
</code></pre></li>
<li>
<p>Money</p>
<pre><code>public class Money {
	public static Object lock = new Object(); 
	public static volatile int money = 100000;
}
</code></pre></li>
<li>
<p>Demo</p>
<pre><code>public class Volatile {
	public static void main(String[] args) {
        MyThread1 mt1 = new MyThread1();
        mt1.setName(&quot;小路同学&quot;);
        mt1.start();
        		
        MyThread2 mt2 = new MyThread2();
        mt2.setName(&quot;小明同学&quot;);
        mt2.start();
	}
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li>
<p>原子性</p>
<ul>
<li>所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行，并且不会受到任何因素的干扰而中断，要么所有的操作都不执行，多个操作是一个不可以分割的整体</li>
</ul>
</li>
<li>
<p>原子类AtomicInteger</p>
<ul>
<li>
<p><code>public AtomicInteger()</code>:初始化一个默认值为0的原子型Integer</p>
</li>
<li>
<p><code>public AtomicInteger(int initialValue)</code>:初始化一个指定值的原子型Integer</p>
</li>
<li>
<p><code>int ger()</code>:获取值</p>
</li>
<li>
<p><code>int getAndlncrement()</code>:以原子方式将当前值加1，注意：这里返回的是自增前的值</p>
</li>
<li>
<p><code>int incrementAndGet()</code>:以原子方式将当前值加1，注意：这里返回的是自增后的值</p>
</li>
<li>
<p><code>int addAndGet(int data)</code>:以原子方式将输入的数值与实例中的值(AtomicInteger里的value)相加，并返回结果</p>
</li>
<li>
<p><code>int getAndSet(int value)</code>:以原子方式设置为newValue的值，并返回旧值</p>
<pre><code>public class MyAtomIntegerDemo1 {
    public static void main(String[] args) {
        AtomicInteger a1 = new AtomicInteger(10);
        //int ger():获取值
        System.out.println(a1.get());
      
        //int getAndIncrement():以原子方式将当前值加1，注意：这里返回的是自增前的值
        int andIncrement = a1.getAndIncrement();
        System.out.println(andIncrement);
        System.out.println(a1.get());
      
        //int incrementAndGet():以原子方式将当前值加1，注意：这里返回的是自增后的值
        int i = a1.incrementAndGet();
        System.out.println(i);
        System.out.println(a1.get());
      
        //int addAndGet(int data):以原子方式将输入的数值与实例中的值(AtomicInteger里的value)相加，并返回结果
        int i1 = a1.addAndGet(10);
        System.out.println(i1);
      
        //int getAndSet(int value):以原子方式设置为newValue的值，并返回旧值
        int andSet = a1.getAndSet(8);
        System.out.println(andSet);
      
    }
}
</code></pre></li>
<li>
<p>代码实现送冰淇淋</p>
</li>
<li>
<p>AtomDemo类</p>
<pre><code>public class AtomDemo {
    public static void main(String[] args) {
        MyThreadDemo m1 = new MyThreadDemo();
        for (int i = 0; i &lt; 100; i++) {
            new Thread(m1).start();
        }
    }
}
</code></pre></li>
<li>
<p>MyThreadDemo类</p>
<pre><code>public class MyThreadDemo implements Runnable{
    AtomicInteger ac = new AtomicInteger(0);
      
    @Override
    public void run() {
        for (int i = 0; i &lt; 100; i++) {
            int count = ac.incrementAndGet();
            System.out.println(&quot;已经送了&quot;+count+&quot;个冰淇淋&quot;);
        }
    }
}
</code></pre></li>
</ul>
</li>
<li>
<p>synchronized和CAS的区别</p>
<ul>
<li>相同点：在多线程情况下，都可以保证共享数据的安全性</li>
<li>不同点：synchronized总是从最坏的角度出发，认为每次获取数据的时候，别人都有可能修改，所以在每次操作共享数据之前，都会上锁。(悲观锁)</li>
<li>cas是从乐观的角度出发，假设每次获取数据别人都不会修改，所以不会上锁，只不过在修改共享数据的时候，会检查一下，别人有没有修改过这个数据。如果别人修改过，那么我再次获取现在最新的值，如果别人没有修改过，那么现在直接修改共享数据的值。(乐观锁)</li>
</ul>
</li>
<li>
<p>并发工具类</p>
<ul>
<li>Hashtable
<ul>
<li>HashMap是线程不安全的(多线程环境下可能会存在问题)</li>
<li>为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下</li>
<li>Hashtable采取悲观锁synchronized的形式保证数据的安全性</li>
<li>只要有线程访问，会将整张表全部锁起来，所以Hashtable的效率地下</li>
</ul>
</li>
</ul>
</li>
<li>
<p>ConcurrentHashMap</p>
<ul>
<li>
<p>ConcurrentHashMap也是线程安全的，效率较高</p>
<p>jdk1.7版本</p>
</li>
<li>
<p>大数组总结</p>
<ul>
<li>默认创建一个长度16,加载因子为0.75的大数组，这个数组一旦创建无法扩容</li>
<li>还会创建一个长度为2的小数组，把地址值赋给给0索引处，其它索引位置的元素都是null</li>
</ul>
</li>
<li>
<p>小数组总结</p>
<ul>
<li>第一次会根据键的哈希值来计算出在大数组中应存入的位置</li>
<li>如果为null，则按照模板创建小数组，创建完毕，会二次哈希，计算出在小数组中应存入的位置，直接存入。</li>
<li>如果不为null，就会根据记录的地址值找到小数组，二次哈希计算出在小数组应存入的位置，如果需要扩容，则将小数组扩容两倍，如果不需要扩容，则判断小数组这个位置有没有元素，如果没有元素，则直接存，如果有元素则会通过调用equals方法，比较属性值，如果equals为true则不存，如果equals为false，则形成哈希桶结构。</li>
</ul>
<p>jdk1.8版本</p>
</li>
<li>
<p>如果使用空参构造创建ConcurrentHashMap对象，则什么事情都不做，在第一次添加元素的时候创建哈希表</p>
</li>
<li>
<p>计算当前元素应存入的索引</p>
</li>
<li>
<p>如果该索引位置为null，则利用cas算法，将本结点添加到数组中</p>
</li>
<li>
<p>如果该索引位置不为null，则利用volatile关键字获得当前位置最新的结点地址，挂在他下面，变成链表</p>
</li>
<li>
<p>当链表的长度大于等于8时，自动转换成红黑树</p>
</li>
<li>
<p>以链表或者红黑树头结点为锁对象，配合悲观锁保证多线程操作集合时数据的安全性</p>
</li>
</ul>
</li>
<li>
<p>CountDownLatch</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public CountDownLatch(int count)</td>
<td>参数传递线程数，表示等待线程数量</td>
</tr>
<tr>
<td>public void await()</td>
<td>让线程等待</td>
</tr>
<tr>
<td>public void countDown()</td>
<td>当前线程执行完毕</td>
</tr>
</tbody>
</table>
<ul>
<li>使用场景
<ul>
<li>让某一条线程等待其他线程执行完毕之后在执行</li>
<li><code>CountDownLatch(int count)</code>:参数写等待线程的数量，并定义了一个计数器</li>
<li><code>await()</code>:让线程等待，当计数器为0时，会唤醒等待的线程</li>
<li><code>countDown()</code>：线程执行完毕时调用，会将计数器-1</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Semaphore</p>
<ul>
<li>
<p>创建Semaphore对象</p>
</li>
<li>
<p>axquire()发通行证</p>
</li>
<li>
<p>release()收回通行证</p>
</li>
<li>
<p>代码演示</p>
<pre><code>public class MyRunable implements Runnable{
	private Semaphore semaphore = new Semaphore(2);
	@Override
	public void run() {
      //获得通行证
      try {
          semaphore.acquire();
          //开始行驶
          System.out.println(&quot;获得通行证开始行驶&quot;);
          Thread.sleep(2000);
          System.out.println(&quot;归还通行证&quot;);
          semaphore.release();
      } catch (InterruptedException e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
      }
	}
}
</code></pre></li>
<li>
<p>测试类</p>
<pre><code>public class MySemaphoreDemo {
	public static void main(String[] args) {
      MyRunable m1 = new MyRunable();
      for (int i =1; i &lt;= 100; i++) {
          new Thread(m1).start();
      }
	}
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>pengSite </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=/2017/duoxianc/>/2017/duoxianc/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="/tags/java/">
                    #java</a></span>
            
            <span class="tag"><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">
                    #多线程</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="/">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="/2017/stream/" class="prev" rel="prev" title="File与IO详解"><i class="iconfont icon-left"></i>&nbsp;File与IO详解</a>
         
        
        <a href="/2017/wlbc/" class="next" rel="next" title="java网络编程">java网络编程&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2017 - 2021</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="/">pengSite</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
    
    <script src="/js/vendor_no_gallery.min.js" async=""></script>
    
  



     </div>
  </body>
</html>
